name: Backend CI/CD

on:
  pull_request:
  push:
    branches:
      - main
  workflow_dispatch:

permissions:
  contents: read
  packages: write

concurrency:
  group: backend-${{ github.ref }}
  cancel-in-progress: true

env:
  PYTHON_VERSION: "3.12"
  IMAGE_NAME: ghcr.io/nero-service/sausalito-be
  GHCR_DEPLOY_USERNAME: pump9918

jobs:
  test:
    runs-on: ubuntu-latest
    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Setup Python
        uses: actions/setup-python@v5
        with:
          python-version: ${{ env.PYTHON_VERSION }}
          cache: pip
          cache-dependency-path: requirements/local.txt

      - name: Install dependencies
        run: |
          python -m pip install --upgrade pip
          pip install -r requirements/local.txt

      - name: Install ripgrep
        run: |
          sudo apt-get update
          sudo apt-get install -y ripgrep

      - name: Run security checks
        run: ./scripts/check_sensitive.sh

      - name: Run tests
        run: python manage.py test --verbosity 2
        env:
          DJANGO_SETTINGS_MODULE: config.settings.local
          DJANGO_DEBUG: "true"
          DJANGO_SECRET_KEY: ci-secret-key
          DB_ENGINE: sqlite3

      - name: Validate compose configuration
        run: |
          cp .env.prod.example .env.prod
          docker compose config > /tmp/docker-compose.validated.yaml
          rm -f .env.prod

      - name: Validate production env template
        run: ./scripts/validate_env_prod.sh --file .env.prod.example --template

      - name: Validate shell scripts syntax
        run: |
          bash -n scripts/check_sensitive.sh
          bash -n scripts/validate_env_prod.sh
          bash -n scripts/predeploy_check.sh
          bash -n scripts/deploy_backend.sh
          bash -n scripts/ssl/bootstrap_letsencrypt.sh
          bash -n scripts/ssl/renew_letsencrypt.sh
          bash -n scripts/ssl/enable_https_conf.sh
          bash -n scripts/systemd/install_runtime_automation.sh
          bash -n scripts/maintenance/prune_docker.sh
          bash -n scripts/maintenance/disk_guard.sh
          bash -n scripts/maintenance/runtime_guard.sh
          bash -n scripts/maintenance/backup_guard.sh
          bash -n scripts/maintenance/backup_postgres_to_object_storage.sh

  build-and-push:
    if: github.event_name != 'pull_request'
    runs-on: ubuntu-latest
    needs: test
    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Login to GHCR
        uses: docker/login-action@v3
        with:
          registry: ghcr.io
          username: ${{ env.GHCR_DEPLOY_USERNAME }}
          password: ${{ secrets.GHCR_TOKEN }}

      - name: Setup Docker Buildx
        uses: docker/setup-buildx-action@v3

      - name: Build and push image
        uses: docker/build-push-action@v6
        with:
          context: .
          file: ./Dockerfile
          push: true
          tags: |
            ${{ env.IMAGE_NAME }}:${{ github.sha }}
            ${{ env.IMAGE_NAME }}:latest
          cache-from: type=gha
          cache-to: type=gha,mode=max

  deploy:
    if: github.event_name != 'pull_request' && github.ref == 'refs/heads/main'
    runs-on: ubuntu-latest
    needs: build-and-push
    environment: production
    env:
      DEPLOY_SSH_AUTO_SYNC: ${{ secrets.DEPLOY_SSH_AUTO_SYNC }}
    steps:
      - name: Validate required deploy secrets
        env:
          DEPLOY_HOST: ${{ secrets.DEPLOY_HOST }}
          DEPLOY_USER: ${{ secrets.DEPLOY_USER }}
          DEPLOY_PORT: ${{ secrets.DEPLOY_PORT }}
          DEPLOY_PATH: ${{ secrets.DEPLOY_PATH }}
          DEPLOY_SSH_KEY_RAW: ${{ secrets.DEPLOY_SSH_KEY }}
          DEPLOY_SSH_PUBLIC_KEY: ${{ secrets.DEPLOY_SSH_PUBLIC_KEY }}
          DEPLOY_SSH_PASSPHRASE: ${{ secrets.DEPLOY_SSH_PASSPHRASE }}
          DEPLOY_SSH_AUTO_SYNC: ${{ secrets.DEPLOY_SSH_AUTO_SYNC }}
          GCP_PROJECT_ID: ${{ secrets.GCP_PROJECT_ID }}
          GCP_ZONE: ${{ secrets.GCP_ZONE }}
          GCP_INSTANCE_NAME: ${{ secrets.GCP_INSTANCE_NAME }}
          GCP_SERVICE_ACCOUNT_JSON: ${{ secrets.GCP_SERVICE_ACCOUNT_JSON }}
          GHCR_TOKEN: ${{ secrets.GHCR_TOKEN }}
        run: |
          set -euo pipefail
          : "${DEPLOY_HOST:?DEPLOY_HOST is required}"
          : "${DEPLOY_USER:?DEPLOY_USER is required}"
          : "${DEPLOY_PORT:?DEPLOY_PORT is required}"
          : "${DEPLOY_PATH:?DEPLOY_PATH is required}"
          : "${GHCR_TOKEN:?GHCR_TOKEN is required}"
          : "${DEPLOY_SSH_KEY_RAW:?DEPLOY_SSH_KEY is required}"

          if ! grep -q "BEGIN .*PRIVATE KEY" <<<"${DEPLOY_SSH_KEY_RAW}"; then
            echo "::error::DEPLOY_SSH_KEY must be a private key (BEGIN ... PRIVATE KEY)."
            exit 1
          fi

          key_file="$(mktemp)"
          trap 'rm -f "${key_file}"' EXIT
          printf '%s\n' "${DEPLOY_SSH_KEY_RAW}" | sed 's/\r$//' > "${key_file}"
          chmod 600 "${key_file}"

          if grep -q '\\n' "${key_file}"; then
            echo "::error::DEPLOY_SSH_KEY contains literal \\n. Paste the raw multi-line private key."
            exit 1
          fi

          if [ -n "${DEPLOY_SSH_PASSPHRASE:-}" ]; then
            if ! ssh-keygen -y -f "${key_file}" -P "${DEPLOY_SSH_PASSPHRASE}" >/dev/null 2>&1; then
              echo "::error::DEPLOY_SSH_KEY parse failed with DEPLOY_SSH_PASSPHRASE."
              exit 1
            fi
            echo "::notice::Key parse OK (passphrase-protected). SSH dry-run skipped."
          else
            if ! ssh-keygen -y -f "${key_file}" >/dev/null 2>&1; then
              echo "::error::DEPLOY_SSH_KEY parse failed. If key is encrypted, set DEPLOY_SSH_PASSPHRASE."
              exit 1
            fi
            if [ "${DEPLOY_SSH_AUTO_SYNC:-false}" != "true" ]; then
              timeout 15 ssh -i "${key_file}" \
                -o BatchMode=yes \
                -o StrictHostKeyChecking=accept-new \
                -o ConnectTimeout=10 \
                -p "${DEPLOY_PORT}" \
                "${DEPLOY_USER}@${DEPLOY_HOST}" \
                "echo ssh_auth_ok" >/dev/null
            fi
          fi

          if [ "${DEPLOY_SSH_AUTO_SYNC:-false}" = "true" ]; then
            : "${DEPLOY_SSH_PUBLIC_KEY:?DEPLOY_SSH_PUBLIC_KEY is required when DEPLOY_SSH_AUTO_SYNC=true}"
            : "${GCP_PROJECT_ID:?GCP_PROJECT_ID is required when DEPLOY_SSH_AUTO_SYNC=true}"
            : "${GCP_ZONE:?GCP_ZONE is required when DEPLOY_SSH_AUTO_SYNC=true}"
            : "${GCP_INSTANCE_NAME:?GCP_INSTANCE_NAME is required when DEPLOY_SSH_AUTO_SYNC=true}"
            : "${GCP_SERVICE_ACCOUNT_JSON:?GCP_SERVICE_ACCOUNT_JSON is required when DEPLOY_SSH_AUTO_SYNC=true}"
            if ! grep -Eq '^ssh-(ed25519|rsa) [A-Za-z0-9+/=]+' <<<"${DEPLOY_SSH_PUBLIC_KEY}"; then
              echo "::error::DEPLOY_SSH_PUBLIC_KEY format is invalid."
              exit 1
            fi
          fi

      - name: Auth to GCP (SSH key sync)
        if: ${{ env.DEPLOY_SSH_AUTO_SYNC == 'true' }}
        uses: google-github-actions/auth@v2
        with:
          credentials_json: ${{ secrets.GCP_SERVICE_ACCOUNT_JSON }}

      - name: Setup gcloud (SSH key sync)
        if: ${{ env.DEPLOY_SSH_AUTO_SYNC == 'true' }}
        uses: google-github-actions/setup-gcloud@v2

      - name: Sync deploy public key to VM metadata
        if: ${{ env.DEPLOY_SSH_AUTO_SYNC == 'true' }}
        env:
          DEPLOY_USER: ${{ secrets.DEPLOY_USER }}
          DEPLOY_SSH_PUBLIC_KEY: ${{ secrets.DEPLOY_SSH_PUBLIC_KEY }}
          GCP_PROJECT_ID: ${{ secrets.GCP_PROJECT_ID }}
          GCP_ZONE: ${{ secrets.GCP_ZONE }}
          GCP_INSTANCE_NAME: ${{ secrets.GCP_INSTANCE_NAME }}
        run: |
          set -euo pipefail
          instance_oslogin="$(
            gcloud compute instances describe "${GCP_INSTANCE_NAME}" \
              --project "${GCP_PROJECT_ID}" \
              --zone "${GCP_ZONE}" \
              --format='get(metadata.items.enable-oslogin)' || true
          )"
          project_oslogin="$(
            gcloud compute project-info describe \
              --project "${GCP_PROJECT_ID}" \
              --format='get(commonInstanceMetadata.items.enable-oslogin)' || true
          )"
          if [ "${instance_oslogin}" = "TRUE" ] || [ "${instance_oslogin}" = "true" ] || [ "${project_oslogin}" = "TRUE" ] || [ "${project_oslogin}" = "true" ]; then
            echo "::error::OS Login is enabled. Instance metadata ssh-keys sync is ignored. Disable OS Login or switch to OS Login based deploy."
            exit 1
          fi

          current_keys="$(
            gcloud compute instances describe "${GCP_INSTANCE_NAME}" \
              --project "${GCP_PROJECT_ID}" \
              --zone "${GCP_ZONE}" \
              --format='get(metadata.items.ssh-keys)' || true
          )"

          tmp_keys="$(mktemp)"
          trap 'rm -f "${tmp_keys}"' EXIT
          if [ -n "${current_keys}" ]; then
            printf '%s\n' "${current_keys}" > "${tmp_keys}"
          fi
          sed -i '/^[[:space:]]*$/d' "${tmp_keys}" || true

          key_line="${DEPLOY_USER}:${DEPLOY_SSH_PUBLIC_KEY}"
          if ! grep -Fqx "${key_line}" "${tmp_keys}" 2>/dev/null; then
            printf '%s\n' "${key_line}" >> "${tmp_keys}"
          fi

          gcloud compute instances add-metadata "${GCP_INSTANCE_NAME}" \
            --project "${GCP_PROJECT_ID}" \
            --zone "${GCP_ZONE}" \
            --metadata-from-file "ssh-keys=${tmp_keys}"

      - name: Deploy via SSH
        uses: appleboy/ssh-action@v1.2.0
        with:
          host: ${{ secrets.DEPLOY_HOST }}
          username: ${{ secrets.DEPLOY_USER }}
          key: ${{ secrets.DEPLOY_SSH_KEY }}
          passphrase: ${{ secrets.DEPLOY_SSH_PASSPHRASE }}
          port: ${{ secrets.DEPLOY_PORT }}
          timeout: 30s
          command_timeout: 20m
          script_stop: true
          script: |
            set -euo pipefail
            cd ${{ secrets.DEPLOY_PATH }}
            export GHCR_TOKEN="${{ secrets.GHCR_TOKEN }}"
            export GHCR_DEPLOY_USERNAME="${{ env.GHCR_DEPLOY_USERNAME }}"
            export BACKEND_IMAGE=${{ env.IMAGE_NAME }}
            export IMAGE_TAG=${{ github.sha }}
            git pull --ff-only origin main
            echo "${GHCR_TOKEN}" | docker login ghcr.io -u "${GHCR_DEPLOY_USERNAME}" --password-stdin
            ./scripts/deploy_backend.sh
